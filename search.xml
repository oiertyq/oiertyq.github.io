<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[sol - 19.8.10]]></title>
    <url>%2Fsol-19-8-10%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[讲义集]]></title>
    <url>%2F%E8%AE%B2%E4%B9%89%E9%9B%86%2F</url>
    <content type="text"><![CDATA[tyq的主页! function load() { window.location.href='/about'; } function toload() { window.location.href='讲义集'; } ​ ​ 进入tyq的主页! ​ 下载讲义 ​]]></content>
  </entry>
  <entry>
    <title><![CDATA[UOJ#2]]></title>
    <url>%2FUOJ%232%2F</url>
    <content type="text"><![CDATA[这道题我们设两个bitset（N和Y） $N_i = cal(i,0) , Y_i=cal(i,1)$ cal(i) 即第i位经过题目中的计算后所得出来的值 然后贪心。倒序循环i，考虑第i位如何决策 若$N_i$ = 1 ， 显然这一位选0好 若$Y_i$ = 1 ， 那么在不超过限制的情况下，这位应该选1 否则直接选0 倒序循环防止较小数选择过多导致较大数无法被选中导致答案错误 Code:123456789101112131415161718192021222324252627#include&lt;iostream&gt;#include&lt;bitset&gt;#include&lt;cstdio&gt;using namespace std ;bitset&lt;50&gt; N,Y ;int ans = 0 ;int n,m,res ;string instr ;int main()&#123; N.reset() , Y.set() ; scanf("%d%d",&amp;n,&amp;m) ; while(n--)&#123; int x; cin&gt;&gt;instr&gt;&gt;x ; if(instr[0] == 'A') N&amp;=x,Y&amp;=x ; else if(instr[0] == 'O') N|=x,Y|=x ; else N^=x,Y^=x ; &#125; for(int i=30;i&gt;=0;--i)&#123; if((N[i] == 1)) ans += (1&lt;&lt;i) ; else if(Y[i]==1 &amp;&amp; (res+(1&lt;&lt;i)&lt;=m)) ans+=(1&lt;&lt;i) , res+=(1&lt;&lt;i) ; &#125; cout&lt;&lt;ans&lt;&lt;endl ;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[JXCPC试题册]]></title>
    <url>%2FJXCPC%E8%AF%95%E9%A2%98%E5%86%8C%2F</url>
    <content type="text"><![CDATA[JXCPC 试题册Input file: standard input Output file: standard output Time limit: 1s Memory limit: 256 megabytes Problem A. CotreeAvin has two trees which are not connected. He asks you to add an edge between them to make them connected while minimizing the function $\sum_{i=1}^{n} \sum_{j=i+1}^{n} dis(i,j)$ ,where dis(i,j) represents the number of edges of the path from _i_ to _j_ . He is happy with only the function value. InputThe first line contains a number _n_($2 \leq n \leq 100,000$). In each of the following _n-2_ lines , there are two numbers _u_ and _v_ , meaning that there is an edge between _u_ and _v_ .The input is guaranteed to contain exactly two trees. OutputJust print the minimum function value 中文简述题意给出两棵树T1,T2，连接一条边使得这两颗树合成一棵树，你所连的边要使$\sum_{i=1}^{n} \sum_{j=i+1}^{n} dis(i,j)$最小，dis(i,j)指链接i,j的简单路径所含边的数目 Example Input 1231 2 Output 14 Problem B.MathAvin sells robots to clients. At second 0,Avin is at the location (0,0) on a number axis with a robot. He wants to go to (_L_,0) with the robot. He walks a unit distance per second , and he can only stop at integer coordinates. Now he decides to follow these walking rules repeatedly until he arrives (_L_,0) with the robot : 1) If Avin has the robot with himself,the robot may be dropped down with probability _p_ 2) If Avin had dropped the robot , he will figure it out with probability _q_. Specially, if Avin arrives at (_L_,0) without robot , he will trun around immediately 3) If Avin does not see that the robot had been dropped, he walks one step right; otherwise, he walks left until he is at the same location as the robot. What is the expectation of walking time he needs to arrive (_L_,0) with the robot. 中文简述题意Avin要带着机器人从0走到L，走路速度为每秒一格并且只会在整数格停下，他走路按照以下规则： 如果Avin没有弄丢机器人，则有p的概率弄丢机器人 如果Avin已经弄丢了机器人，则有q的概率发现，特别的，当他到达终点却没有机器人时，会立刻发现 如果Avin发现他弄丢了机器人，则会一直往左走直到遇见机器人，否则他会向右走一格 InputOne line with three numbers _L_,_p_ and _q_, where _L_($1\leq L \leq100,000$) is an integer,_p_ and _q_ are real numbers with three digits and within(0,1) OutputPrint the expected walking time . Your answer is considered correct if the absolute or relative error doesn’t exceed $10^{-6}$.Formally, let you answer be _a_ , and the jury’s answer be _b_. Your answer is considered correct if $\frac{|a-b|}{max(1,|b|)} \leq 10^{-6}$ Problem C.TrapGuGuGu Problem D.WaveAvin is studying series. A series is called “wave” if the following conditions are satiffied: 1) It contains at least two elements 2) All elements at odd positions are the same 3) All elements at even positions are the same 4) Elements at odd positions are NOT the same as the elements at even positions You are given a series with length _n_. Avin asks you to find the longest “wave” subseries. A subseries is a subsequence of a series. InputThe first line contains two numbers _n_,_c_($1 \leq n \leq 100,000, 1 \leq c \leq 100$). The second line contains _n_ integers whose range is [1,c] , which represents the series. It is guaranteed that there is always a “wave” subseries. OutputPrint the length of the longest “wave” subseries. 插几句嘴qwq本题考试时$O(nc^2)$可以通过,实际上$O(nc^2) \leq O(10^5 \times (10^2)^2) = O(10^9)$,不能通过 所以很迷…我写的是$O(nc)$ Example Input 125 31 2 1 3 2 Output 14 Problem E.PackingGuGuGu Problem F.StringAvin has a string. He would like to uniform-randomly select four characters (selecting the same character is allowed) from it. You are asked to calculate to probability of four characters being “_avin_” in order. InputThe first line contains _n_($1 \leq n \leq 100$), the length of the string. The second line contains the string. To simplify the problem , the characters of the string are from ‘a’ , ‘v’ , ‘i’ , ‘n’. OutputPrint the reduced fraction (the greatest common divisor of the numerator and denominator is 1),representing the probability. If the answer is 0 , you should output “0/1” Example Input1 124avin Output1 11/256 Input2 124aaaa Output2 10/1 Problem G.TrafficGuGuGu Problem H.RNG(RNG 牛逼)Avin is studying how to synthesize data . Given a integer _n_, he constructs ans interval using the following method: He first generates a integer _r_ between _1_ and _n_ (both inclusize) uniform-randomly, and generates a integer _l_ between _1_ and _r_ (both inclusize) uniform-randomly. The interval [l,r] is the constructed. Avin has constructed two intervals using the method above. He asks you what the probalility that two intervals intersect(相交) is. You should print $q \times q^{-1}(MOD 1,000,000,007)$, while $\frac{p}{q}$ denoting the probalility. InputJust one line contains the number n ($1 \leq n \leq 1,000,000$) OutputPrint the answer Example Input1 11 Output1 11 Input2 12 Output2 1750000006 Problem I.BudgetAvin’s company has many ongoing projects with difference budgets. His company records the budgets using numbers rounded to 3 digits after the decimal place.However, the company is updating the system and all budgets will be rounded up to 2 digits after the decimal place. For example, 1.004 will be rounded down to 1.00 while 1.995 will be rounded up to 2.00. Avin wants to konw the difference of the total budget caused by update. InputThe first line contains an integer _n_($1 \leq n \leq 1,000$). The second line contains _n_ decimals, and the i-th decimal $a_i$($0 \leq n \leq 10^{18}$) repersents the budget of the i-th project. All decimals are rounded to 3 digits. OutputPrint the difference rounded to 3 digits. Example Input1 1211.001 Output1 1-0.001 Input2 1210.999 Output2 10.001 Input3 1221.001 0.999 Output3 10.000 Problem J.WorkerAvin meets a rich customer today. He will earn 1 million dollars if he can solve a hard problem. There are _n_ warehouses and _m_ workers. Any worker in the i-th warehouse can handle $a_i$ orders per day. The customer wonders whether there exists one worker assignment method satiisfying that every warehouse handles the ssame number of orders every day. Note that each worker should be assigned to exactly warehouse and no worker is lazy when working. InputThe first line contains two integers n($1 \leq n \leq 1,000$) ,m($1 \leq m \leq 10^{18}$). The second lie contains _n_ integers. The i-th integer $a_i$ ($1 \leq a_i \leq 10$) represensts one worker in the i-th warehouse can handle $a_i$ orders per day. OutputIf there is feasible assignment method, orint “Yes” in the first line. Then , i th second line, print n integers with i-th integer representing the number of workers assigned too the i-th warehouse. Otherwise , print “No” in one line. If there are multiple solutions, any is accepted. Example Input1 122 61 2 Output1 12Yes4 2 Input2 122 51 2 Output2 1No Problem K.ClassAvin has two integers _a_,_b_($1 \leq a,b \leq 1,000$). Given _x_=_a_+_b_ and _y_=_a_-_b_, can you calculate a*b? InputThe first line contains two integers _x_,_y_. OutputPrint the result of a*b. Example Input1 14 2 Output1 13]]></content>
  </entry>
  <entry>
    <title><![CDATA[BZOJ4001]]></title>
    <url>%2FBZOJ4001%2F</url>
    <content type="text"><![CDATA[BZOJ 4001 概率论设$f_i$表示i个点的二叉树方案数 立刻有$f_i = \sum{i=0}^{i-1} f_i f_{n-i-1}$ 设$F(x)为序列f的生成函数，有F(x)^2 = \sum_{i=0}^{+\infty} \sum_{i+j = n} f_i f_j x^i$ 可设$g(x) = f(x+1) = \sum_{i+j = x} f_i f_j$($G(x)为序列g的生成函数$) 有: $G(x) = F(x)^2$， 又有$F(x) = xG(x)+f(0)$，所以解得$F(x) = (2x)^{-1} (1-(1-4x)^{\frac{1}{2}})$ 有二项式定理展开得$F(x) = (2x)^{-1} (1-\sum_{i=0}^{+\infty} \dbinom{\frac{1}{2}}{i} (-4)^i)x^i)$ 考虑化简$\sum_{i=0}^{+\infty} \dbinom{\frac{1}{2}}{i} (-4)^i)$ 由组合数定义可知， $\dbinom{\frac{1}{2}}{i} (-4)^i = -\sum_{i=0}^{+\infty} (2i-1)^{-1} \dbinom{2i}{i}$ 原式化简为$F(x) = (2x)^{-1} (1+\sum_{i=0}^{+\infty} (2i-1)^{-1} \dbinom{2i}{i})x^i)$，有后式在x=0时取-1，消去前面的1，然后消去2x，可化简为$F(x) = \sum_{i=0}^{+\infty} \frac{1}{4i+2} \dbinom{2i+2}{i+1}x^i$，拆去组合数得$F(x) = \sum_{i=0}^{+\infty} \frac{1}{i+1} \dbinom{2i}{i} x^i$，即$f_i = \frac{1}{i+1} \dbinom{2i}{i}$ 同理设节点数为i的所有二叉树的叶子种数为$h_i$($H(x)为序列的生成函数$)，$H(x) = \frac{x}{\sqrt{1-4x}}$，同理得$h_i = \dbinom{2i-2}{i-1}$，可得$答案=\frac{h_i}{f_i}=\frac{n(n+1)}{2(2n-1)}$ 代码:12345678910#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;using namespace std ;int n; double p ;int main()&#123; scanf("%d",&amp;n) ; p = n/1.000000000 ; printf("%.9lf",((p)*(p+1)) / (2 * (2*p - 1))) ;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[sol-19.8.9]]></title>
    <url>%2Fsol-19-8-9%2F</url>
    <content type="text"><![CDATA[T1Dinic最大流模板 错误: 会但是没拿满分, 因为建点时起点为1而其他所有点要+1 T2最小表示法模板 错误: 会但是没拿满分, 因为最小表示法数组*2 T3分治Floyd]]></content>
      <tags>
        <tag>sol-集训</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络流定理总结]]></title>
    <url>%2F%E7%BD%91%E7%BB%9C%E6%B5%81%E5%AE%9A%E7%90%86%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[By tyqtyq, 若有遗漏请点击左边链接谢谢 任意图 $最大流 = 最小割$ 证明略 $最大权闭合子图的权值和 = 正权节点权值和-最小割$ 在一个图中，我们选取一些点构成集合，记为V，且集合中的出边(即集合中的点的向外连出的弧)，所指向的终点(弧头)也在V中，则我们称V为闭合图。最大权闭合 图即在所有闭合图中，集合中点的权值之和最大的V，我们称V为最大权闭合图。 此时，构建一个超级源点s，一个超级汇点t，所有的点按权值的正负连接到s和t上，转换成一个边权值有向图 有最大权闭合子图的权值和 = 正权节点权值和-最小割 DAG 有向无环图类别 $二分图最小点覆盖的点数=最大匹配数\;\;\;最大独立集=最小路径覆盖的边数=顶点数n-最大匹配数$ 最小路径覆盖定义: 用最少的路径覆盖整个图的所有顶点各一次(路径可以为一个点) G': 把原图中每个点$i$拆分为两个点$i_1,i_2$,若原图中边$(x,y)$存在,则G'中边$(x_1,y_2)$存在 证明 定理证明：如果匹配数为零，那么P中不存在有向边，于是显然有最小路径覆盖=|G|－最大匹配数=|G|。在匹配数为0的基础上，即S中一条边没有，如果在S中增加一条匹配边(i1,j2)，那么在图G的路径覆盖中就存在一条由i连接j的边，也就是说i与j 在一条路径上，于是路径覆盖数就可以减少一个；如此继续增加匹配边，每增加一条，路径覆盖数就减少一条；直到匹配边不能继续增加时，路径覆盖数也不能再减少了；但是这里只 是说明了每条匹配边对应于路径覆盖中的一条路径上的一条连接两个点之间的有向边；下面来说明一个路径覆盖中的每条连接两个顶点之间的有向边对应于一条匹配 边。与前面类似，对于路径覆盖中的每条连接两个顶点之间的每条有向边，我们可以在匹配图中对应作一条连接i1与j2的边， 显然这样做出来二分图中的边均为匹配，即连接的X和Y中的两个点之前都未匹配过，否则匹配过的那个点对应原图时就被覆盖两次，与路径覆盖矛盾。这就说明匹配边与路径覆盖图中连接两顶点之间边的一一对应关系，那么也就说明了前面的公式成立，即S中每增加一条匹配边，路径覆盖数减少1.(引用来自以上链接) 代码: #define getpoint(i,X) (X == 1)?(i):(i+n) void dfs(int n){ for(int i=head[n]; i; i=Next[i]){ int v = ver[i] ; add_new(getpoint(i,1),getpoint(p,2)) ; dfs(v) ; } } void work(){ dfs(1) ; } $最小可重路径覆盖$ 设$w_{i,j}$为原DAG中i能否到达j 以w为邻接矩阵即可 二分图 $最小顶点覆盖 = 最大匹配 = 所有顶点数-最大独立集$ 证明略 $最大团 = 补图的最大独立集$ 证明略 $霍尔定理$ 设一个二分图左侧一点集{S},与其直接相连的点集为{T},若所有$|\{S\}| \leq |\{T\}|,则至少有一个大小为|左侧点集|的匹配$ 证明略 值得一提的是在数轴(黑点匹配距离$\leq k$的)上只需考虑所有区间即可]]></content>
      <tags>
        <tag>网络流,总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[可持久化数据结构学习笔记]]></title>
    <url>%2Fke-chi-jiu-hua-notes%2F</url>
    <content type="text"><![CDATA[可持久化数据结构总述充分利用以前的状态 可持久化Trie树这是一颗插入了”AFK”的可持久化Trie 接下来插入”KFC”,此时新建一个根（因为要可持久化），然后我们来看他该怎么连边 首先，肯定要有”KFC” 其次，还要能访问到以前的节点 然后就可以这么搞： 然后插入”KFK”： 所以我们发现一个这样的算法： ins(u,f) 被定义为一个插入算法 那么对于[a..z]中的字母X，考虑f所连的一条边权为X的边，若其存在，则将root[i]的X指针指向之。特别的，若X是要插入的字符串中正在处理的一位，则不执行以上操作，并将X指针指向一个新的节点，记该节点为t，该字符为m，该边所指向的节点为k 执行完后，递归ins(t,k)，把处理到的位置++ 这样就好啦qwq 可持久化线段树先建树，过程同普通线段树，不再赘述 然后假设建出来一颗这样的： 接下来修改v[1] = 3 ， 根据推理发现应该是这样的： 继续，v[2]=0，树长这样子： OK，代码跟可持久化Trie+线段树样的，然后时间复杂度证明如下： 1.一开始树中只有原始的NlogN个节点2.每次插入会增加一条长度为logN的链 所以总长度为O(NlogN+(N-1)logN)=O((2N-1)logN)=O(NlogN)]]></content>
      <tags>
        <tag>可持久化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解【[BJOI2015]树的同构】]]></title>
    <url>%2Fsol-BJOI2015%2F</url>
    <content type="text"><![CDATA[切了省选题+紫题，来写个题解 这题其实挺水，才120行代码 该题写了我一天（上午1.5h，晚上10min = 一天） hash，对于节点A， hashval[A] = \{hashval[i]\times2333^{num} | i \in son[A] \}， 并且hashval[i]大于任何在他前面加的数，num为目前加到第几个 写成代码就是 1234567891011function Hash(int n)&#123; vector V ; for_each(i in son[n]) do HV[i] = Hash(i) ; V.pushback(HV[i]) ; V.sort() for_each(i in V) HV[n] = HV[n]*2333+HV[i] ; return HV[n]*2333+1002 ; //HV[i]初值为1&#125; 那么对于树中的每个节点做一遍Hash，时间复杂度为O(N \times (N+NlogN+N)) 所以总的的时间复杂度为 O(M \times N \times NlogN) == O(N^3logN)说人话： O(\text{能过}) Talk is free , show me the code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt; #include&lt;cstring&gt;using namespace std ;inline void read(int &amp;x) &#123; char ch=getchar(); int s=0,f=1; while (!(ch&gt;='0'&amp;&amp;ch&lt;='9')) &#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9') &#123; s=(s&lt;&lt;3)+(s&lt;&lt;1)+ch-'0'; ch=getchar(); &#125; x=s*f;&#125;class TREE&#123; private: vector&lt;int&gt; son[55] ; int hashval[55] ; int H[55] ; bool inq[55] ; int size[55] ; int root ; int n ; int check(vector&lt;int&gt; N)&#123; int S = N.size() ; for(int j:N) &#123; if(inq[j]) --S ; &#125; return S ; &#125; public: //这个MIAOMIAOMIAO函数就是Hash啦喵~ int MIAOMIAOMIAO(int n,int f)&#123; inq[n] = true ; vector&lt;int&gt; V ; for(const int &amp; i : son[n])&#123; if(i==f) continue ; //cout&lt;&lt;"dfs in dot "&lt;&lt;i&lt;&lt;endl ; hashval[i] = MIAOMIAOMIAO(i,n) ; //cout&lt;&lt;"HashVal["&lt;&lt;i&lt;&lt;"] = "&lt;&lt;hashval[i]&lt;&lt;endl ; V.push_back(hashval[i]) ; //cout&lt;&lt;"HashVal["&lt;&lt;n&lt;&lt;"] = "&lt;&lt;hashval[n]&lt;&lt;endl ; &#125; sort(V.begin(),V.end()) ; for(const int&amp; i : V) hashval[n] = hashval[n]*2333 + i ; //hashval[n] = 2333*hashval[n] + 1001 ; return hashval[n]*2333+1002 ; &#125; void getsize(int n,int f)&#123; inq[n] = true ; if(!check(son[n])) size[n] = 1 ; for(int i:son[n])&#123; if(i!=f) getsize(i,n) ; size[n] += size[i] ; &#125; &#125; bool comp(const int&amp; a,const int&amp; b)&#123; return a&gt;b ; &#125; int sZ() &#123;return this-&gt;n ;&#125; void init()&#123; read(n) ; for(int i=1;i&lt;=n;++i)&#123; int x ; read(x) ; if(x==0) &#123; root=i ; continue ; &#125; son[x].push_back(i) , son[i].push_back(x) ; &#125; //cout&lt;&lt;"Root = "&lt;&lt;root&lt;&lt;endl ; getsize(root,root) ; memset(inq,0,sizeof(inq)) ; for(int i=1;i&lt;=n;++i)&#123; sort(son[i].begin() , son[i].end() , [this](int a, int b) -&gt; bool &#123; return size[a] &lt; size[b]; &#125;) ; &#125; for(int j=1;j&lt;=n;++j) hashval[j] = 1 ; for(int i=1;i&lt;=n;++i)&#123; MIAOMIAOMIAO(i,i) ; H[i] = hashval[i] ; memset(inq,0,sizeof(inq)) ; for(int j=1;j&lt;=n;++j) hashval[j] = 1 ; &#125; //for(int i=1;i&lt;=n;++i) cout&lt;&lt;H[i]&lt;&lt;" "; //cout&lt;&lt;endl ; &#125; int gethashval(int DI)&#123; return H[DI] ; &#125;&#125; ; TREE Index[55] ;int m ;int HVL[55] ;int ans[55][55] ;int main()&#123; read(m) ; for(int i=1;i&lt;=m;++i)&#123; //cout&lt;&lt;"TREE "&lt;&lt;i&lt;&lt;endl ; Index[i].init() ; HVL[i] = i ; int n = Index[i].sZ() ; for(int j=1;j&lt;=n;++j)&#123; ans[i][j] = Index[i].gethashval(j) ; &#125; sort(ans[i]+1,ans[i]+n+1) ; for(int j=1;j&lt;=i;++j)&#123; int k = 0 ; while(k&lt;=n) if(ans[i][++k]!=ans[j][k]) break ; if(k&gt;n) &#123; HVL[i] = j ; break ; &#125; &#125; &#125; for(int i=1;i&lt;=m;++i) &#123; printf("%d\n",HVL[i]) ; &#125;&#125; Oh对了 本代码使用C++11标准并对每棵树封装 提交时注意（我不会告诉你我因为这个WA了一次喵~） 还有说下那个for for(const int&amp; i : vector1) -&gt; 对于每个vector1中的元素i，按vector1中的存放顺序访问 所以这个写起来省力（我不会告诉你还可以写for(auto&amp; i:vector1)但是我忘了写喵~）]]></content>
  </entry>
  <entry>
    <title><![CDATA[题解【[CQOI2017]小Q的棋盘】]]></title>
    <url>%2Fsol-CQOI2017%2F</url>
    <content type="text"><![CDATA[切了水题十分快乐~ 首先发现本题结构一定是颗树~ 本题样例1： 。。没啥用？ 样例2： 这个时候我们发现：根据贪心思想我们希望每次走一步都多走一个点，如果我们选择最长链的话，在链上每走一步就多走了一个点，如果走不完最长链，那答案就是步数+1，而如果走完最长链还有剩余步数的话，每两步可以多访问一个节点，除非已经访问过所有节点。 接下来证明而如果走完最长链还有剩余步数的话，每两步可以多访问一个节点 ： \text{设走过的集合为}S_1\text{，没走到的集合为}S_2\text{，点集为}V\text{，边集为}E \text{那么当}S_1 \neq V\text{时，至少存在一点U，其子节点中至少有一个属于}S_2 \text{因为如果不存在这样的结点，该图就不是联通图，更别说树了} \text{那么在访问该节点时，可以花费一步访问那个儿子，在花费一步回来继续} \text{所以走完最长链还有剩余步数的话，每两步可以多访问一个节点}那么就是道水题啦~ 建议大家去luogu评个红 图片来源：http://bubbleioa.top]]></content>
  </entry>
  <entry>
    <title><![CDATA[题解【[FJOI2018]所罗门王的宝藏】]]></title>
    <url>%2Fsol-FJOI2018%2F</url>
    <content type="text"><![CDATA[本题解同步于luoguemmm切了近年省选题来写题解啦qwq 该题较其他省选题较水吧（否则我再怎么做的出来 思路是图论做法，做法上楼上大佬已经讲的很清楚了，我来谈谈代码实现上的一些细节 \text{设节点1...2n，i}\in\text{1-n表示i行，i}\in\text{(n+1)-2n时表示i-n列} \text{当我们读到一颗绿宝石(x,y,k)时，就从x向y+n连一条权值为k的边} \text{当我们连完边后会发现给一行/一列增加a就相当于把与这个点相连的所有边权值增加a} \text{这个加边权可以转化为加点权} \text{设}onk_i\text{表示在这个节点上的点击次数，} \text{搜索起始节点的初值为与这个节点所连边中权值最小的} \text{那么已知两点i,j以及}edge_{i,j}\text{和}onk_i\text{，那么由题目条件易得}onk_j=edge_{i,j}-onk_i \text{那么直接dfs}时间复杂度为 O(T\times(KlogK+K)) = O(TNlogN)要改进也行，因为我们对于每个点所连边只要边权最小数所以没必要sort，但当我想到这一点时已经AC本题~ Talk\;is\;free\;,\;show\;me\;the\;code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#define MAXN 1005using namespace std ;inline void read(int &amp;x) &#123; scanf("%d",&amp;x) ;&#125;class getsol &#123; public: //========data======== vector&lt;pair&lt;int,int&gt; &gt; edge[MAXN*2] ; //pair第一维是边权，第二维是到达边的编号 int n , m , k , onk[MAXN*2] , inq[MAXN*2] , flag ;//inq表示是否被搜到 //========func======== void add(int x,int y,int v) &#123; edge[x].push_back(make_pair(v,y)) ; //加边 &#125; bool check(int u,int v,int w) &#123; //check , 判断v点是否可行 if(onk[u]+onk[v]!=w) return 0 ; return 1 ; &#125; void dfs(int D) &#123; //cout&lt;&lt;"DFS : START SEARCH IN DOT "&lt;&lt;D&lt;&lt;endl ; if(flag==0) return ; inq[D] = 1 ; for(auto&amp; i : edge[D]) &#123; //对于每个edge[D]中的元素i ///cout&lt;&lt;"DFS : SEARCH IN DOT "&lt;&lt;i.second&lt;&lt;endl ; if(flag==0) return ; //cout&lt;&lt;"In dot : "&lt;&lt;i.second&lt;&lt;endl ; int ver = i.second , edgeval = i.first ; if(inq[ver]) &#123; if(flag==1) //如果答案还是"Yes"那么更新，这里是一个优化~ flag = check(D,ver,edgeval) ; continue ; &#125; else &#123; onk[ver] = edgeval-onk[D] ; dfs(ver) ; &#125; &#125; &#125; void PRINT(int* arr,int n) &#123; for(int i=1; i&lt;=n; ++i) &#123; cout&lt;&lt;"arr["&lt;&lt;i&lt;&lt;"] = "&lt;&lt;arr[i]&lt;&lt;endl ; &#125; &#125; void sol() &#123; flag = true ; read(n) , read(m) , read(k) ; //行的编号为1~n //列的编号为(n+1)~(2*n) //喵~ for(int i=1; i&lt;=k; ++i) &#123; int x,y,v ; read(x) , read(y) , read(v) ; add(x,y+n,v) ; add(y+n,x,v) ; &#125; //cerr&lt;&lt;"FINISH READ"&lt;&lt;endl ; for(int i=1; i&lt;=2*n; ++i) sort(edge[i].begin(),edge[i].end()) ; //cerr&lt;&lt;"FINISH SORT"&lt;&lt;endl ; for(int i=1; i&lt;=2*n; ++i) &#123; if(!inq[i]&amp;&amp;flag&amp;&amp;!edge[i].empty()) &#123; // 注意这里判一下vector是否为空。。因为这个RE了两三次 onk[i] = (*edge[i].begin()).first ; //cerr&lt;&lt;"SEARCH IN DOT "&lt;&lt;i&lt;&lt;endl ; dfs(i) ; &#125; &#125; if(flag==1) &#123; for(int i=1; i&lt;=2*n; ++i) for(auto&amp; j : edge[i]) if(flag==1) //重新check一遍，以免遗漏 flag = check(i,j.second,j.first) ; &#125; if(flag) puts("Yes") ; else puts("No") ; //PRINT(onk,2*n) ; &#125; void clear() &#123; for(int i=1; i&lt;=2*n; ++i) edge[i].clear() ; memset(inq,0,sizeof(onk)) ; memset(onk,0,sizeof(onk)) ; n = m = k = flag = 0 ; &#125;&#125; ;getsol M ;int T ;int main() &#123; //freopen("solo3.in" , "rb" , stdin) ; //freopen("solo3.out", "wb" ,stdout) ; read(T) ; while(T--) M.sol() , M.clear() ;&#125; 注意本代码是使用C++11标准写成，代码中不同不同语法处已标注]]></content>
  </entry>
  <entry>
    <title><![CDATA[题解【[HAOI2006]受欢迎的牛】]]></title>
    <url>%2Fsol-HAOI2006%2F</url>
    <content type="text"><![CDATA[切水题，写题解~ tarjan缩一波点，然后 只有一个出度为0的点：他的size就是答案 有多个初度为0的点：无解，0个 因为是强联通分量，所以肯定有出度为0的点，否则——就是你tarjan写挂了~ Talk\;is\;free\;,\;show\;me\;the\;code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;stack&gt;#include&lt;algorithm&gt;#define MAXN 200000using namespace std ;inline void read(int &amp;x) &#123; char ch=getchar(); int s=0,f=1; while (!(ch&gt;='0'&amp;&amp;ch&lt;='9')) &#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9') &#123; s=(s&lt;&lt;3)+(s&lt;&lt;1)+ch-'0'; ch=getchar(); &#125; x=s*f;&#125;vector&lt;int&gt; edge[MAXN] ;int ins[MAXN] , low[MAXN] , dfn[MAXN] ;int tot , whr[MAXN] ; vector&lt;pair&lt;vector&lt;int&gt;,vector&lt;int&gt; &gt; &gt; scc ;int deg[MAXN] ;int n , m ;void add(int u,int v)&#123; edge[u].push_back(v) ;&#125;void print(stack&lt;int&gt; s)&#123; vector&lt;int&gt; sns ; sns.clear() ; while(!s.empty())&#123; cerr&lt;&lt;s.top()&lt;&lt;" " ; s.pop() ; &#125; cerr&lt;&lt;endl ;&#125;stack&lt;int&gt; idx ;vector&lt;int&gt; ptpuntil(int v , int wr)&#123; //print(idx) ; vector&lt;int&gt; nodes ; while((!idx.empty())&amp;&amp;idx.top()!=v) nodes.push_back(idx.top()) , whr[idx.top()] = wr , idx.pop() ; nodes.push_back(idx.top()) , whr[idx.top()] = wr , idx.pop() ; return nodes ;&#125;int totally = 1 ;void tarjan(int node)&#123; dfn[node] = low[node] = ++totally ; ins[node] = 1 ; idx.push(node) ; for(auto&amp; i:edge[node])&#123; if(dfn[i]==0)&#123; tarjan(i) ; low[node] = min(low[node] , low[i]) ; &#125; else if(ins[node]==1)&#123; low[node] = min(low[node] , dfn[i]) ; &#125; &#125; if(dfn[node]==low[node])&#123; //cout&lt;&lt;"NODE "&lt;&lt;node&lt;&lt;endl ; scc.push_back(make_pair(ptpuntil(node,scc.size()),vector&lt;int&gt;())) ; &#125;&#125;void _add(int a,int b)&#123; if(a!=b) scc[a].second.push_back(b) ;&#125; void join()&#123; //cerr&lt;&lt;"JOIN WORKS!"&lt;&lt;endl ; //cerr&lt;&lt;"n = "&lt;&lt;n&lt;&lt;endl ; for(int i=1;i&lt;=n;++i) for(auto&amp; j : edge[i]) _add(whr[i],whr[j]) ; for(auto&amp; i : scc) sort(i.second.begin(),i.second.end()) , unique(i.second.begin(),i.second.end()) ;&#125;void print(vector&lt;int&gt; V)&#123; for(auto&amp; i : V) cerr&lt;&lt;i&lt;&lt;" " ; &#125;void print(vector&lt;pair&lt;vector&lt;int&gt; , vector&lt;int&gt; &gt; &gt; V)&#123; int m = 0 ; for(auto&amp; i : V)&#123; cerr&lt;&lt;"Vector No."&lt;&lt;++m&lt;&lt;":\n\tfirst :" ; print(i.first) ; cerr&lt;&lt;"\n\tsecond:" ; print(i.second) ; cerr&lt;&lt;endl ; &#125;&#125; void answer()&#123; join() ; //print(scc) ; vector&lt;int&gt; zrs ; zrs.clear() ; for(int i=0;i&lt;scc.size();++i)&#123; if(!scc[i].second.size()) zrs.push_back(i) ; //cout&lt;&lt;"PUSH "&lt;&lt;i&lt;&lt;endl ; &#125; if(zrs.size()&gt;1) printf("0\n") ; else &#123; printf("%d\n",scc[*zrs.begin()].first.size()) ; &#125;&#125;int main()&#123; read(n) , read(m) ; for(int i=1;i&lt;=m;++i)&#123; int x , y ; read(x) , read(y) , add(x,y) ; &#125; for(int i=1;i&lt;=n;++i)&#123; if(!dfn[i]) totally = 0 , tarjan(i) ; &#125; answer() ;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[题解【[BJOI2012]算不出的等式】]]></title>
    <url>%2Fsol-BJOI2012T1%2F</url>
    <content type="text"><![CDATA[题目背景emmm $\text{首先特判掉p=q时的情况（ans = }p^2-1\text{）}$ \text{构造函数}f(k) = \left\lfloor \frac{kq}{p}\right\rfloor \text{考虑这个函数}g(x)=\left\lfloor x \right\rfloor\text{的几何意义} \text{他表示在平面直角坐标系中，横坐标为定值，纵坐标小于等于x的整点个数} \text{好，那么我们继续来看f(k)，他表示所有横坐标为定值，纵坐标小于等于}\frac{kp}{q}\text{的数的个数} \text{那么构造}t(k)=\frac{kq}{p}\text{，那么}\sum_{i=1}^{\frac{p-1}{2}}f(k)\text{的几何意义是：} \text{所有横坐标}\in(1，\frac{p-1}{2})\;\text{的整数，纵坐标是整数的点数}即 中蓝线以下部分中整点数~ \text{又因为}\left\lfloor t(k) \right\rfloor_{max} = \frac{q-1}{2} \text{所有只用考虑纵坐标在直线}\{(0,0),(\frac{p-1}{2},\frac{q-1}{2})\}\text{以下的整点} \text{然后p,q互换同理} \text{所以就是长方形ABCD}(A(0,0),B(0,\frac{p-1}{2}),C(\frac{q-1}{2},\frac{p-1}{2}),D(\frac{q-1}{2},0)\text{中整点个数} \text{所以答案就是}\frac{(p-1)\times(q-1)}{4}然后你就切了这道蓝题~]]></content>
  </entry>
  <entry>
    <title><![CDATA[题解【语文1（chin1）- 理理思维】]]></title>
    <url>%2Fsol-LGP2787%2F</url>
    <content type="text"><![CDATA[link 喵~珂朵莉树AC 珂朵莉树？见此处~ 这数据结构太暴力了，所以不讲了 Code:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;stack&gt;#include&lt;algorithm&gt;#include&lt;set&gt;#include&lt;cctype&gt;#include&lt;cstring&gt;using namespace std ;inline void read(int &amp;x) &#123; char ch=getchar(); int s=0,f=1; while (!(ch&gt;='0'&amp;&amp;ch&lt;='9')) &#123; if (ch=='-') f=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9') &#123; s=(s&lt;&lt;3)+(s&lt;&lt;1)+ch-'0'; ch=getchar(); &#125; x=s*f;&#125;#define ITer set&lt;node&gt;::iteratornamespace odt&#123; struct node&#123; mutable char v ; int l , r ; node(int Ll,int Rr=-1,char Vv=0): l(Ll) , r(Rr) , v(Vv)&#123;&#125; bool operator &lt; (node n)const&#123; return l&lt;n.l ; &#125; &#125; ; set&lt;node&gt; s ; ITer split(int pos)&#123; ITer it = s.lower_bound(node(pos)) ; if(it!=s.end() &amp;&amp; it-&gt;l == pos) return it ; --it ; int L = it-&gt;l , R = it-&gt;r ; char V = it-&gt;v ; s.erase(it) ; s.insert(node(L,pos-1,V)) ; return s.insert(node(pos,R,V)).first ; &#125; void assign_val(int x,int y,char val=0)&#123; val = tolower(val) ; ITer yv = split(y+1) , xv = split(x) ; s.erase(xv,yv) ; s.insert(node(x,y,val)) ; &#125; int query(int x,int y,char k)&#123; k = tolower(k) ; int ans = 0 ; ITer yv = split(y+1) , xv = split(x) ; for(;xv!=yv;++xv) if(xv-&gt;v==k) ans+=xv-&gt;r-xv-&gt;l+1 ; return ans ; &#125; void st(int x,int y)&#123; int ton[257] ; memset(ton,0,sizeof(ton)) ; ITer yv = split(y+1) , xv = split(x) ; ITer it = xv ; for(;xv!=yv;++xv) ton[xv-&gt;v] += xv-&gt;r-xv-&gt;l+1; s.erase(it,yv) ; for(int i=0;i&lt;='z';++i) if(ton[i]) s.insert(node(x,x+ton[i]-1,i)) , x+=ton[i] ; &#125; void print()&#123; ITer x = s.begin() ; for(;x!=s.end();++x)&#123; cerr&lt;&lt;"pair&lt;"&lt;&lt;x-&gt;l&lt;&lt;","&lt;&lt;x-&gt;r&lt;&lt;","&lt;&lt;x-&gt;v&lt;&lt;"&gt; ;"&lt;&lt;endl ; &#125; &#125;&#125;;int n,m ; string ipt ;int nl = 0 ;pair&lt;int,char&gt; pr ;int main()&#123; char last ; read(n) , read(m) ; cin&gt;&gt;ipt ; for(auto&amp; i:ipt) i = tolower(i) ; last = ipt[0] ; pr = make_pair(0,ipt[0]) ; for(int i=0,len=ipt.size();i&lt;=len;++i)&#123; if(ipt[i]==last) ++pr.first ; else&#123; odt::s.insert(odt::node(nl,nl+pr.first-1,pr.second)) ; nl += pr.first ; pr = make_pair(1,ipt[i]) ; last = ipt[i] ; &#125; &#125; odt::print() ; while(m--)&#123; int opt,x,y; char k ; read(opt) ; switch(opt)&#123; case 1: &#123; read(x),read(y),scanf("%c",&amp;k),k=tolower(k),--x,--y,printf("%d\n",odt::query(x,y,k)) ; break ; &#125; case 2: &#123; read(x),read(y),scanf("%c",&amp;k),k=tolower(k),--x,--y,odt::assign_val(x,y,k) ; break ; &#125; case 3: &#123; read(x),read(y),--x,--y,odt::st(x,y) ; break ; &#125; &#125; &#125;&#125; 98行切紫题，爽！]]></content>
  </entry>
</search>
