<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[字符串学习笔记]]></title>
    <url>%2Flearning-strings%2F</url>
    <content type="text"><![CDATA[SAProblem 1 (不同子串个数)题意 求一个字符串的本质不同子串数量 解法 考虑到一个子串就是一个后缀的前缀, 那么我们考虑每一个后缀的贡献, 对于任意一个后缀的”排列”, 我们的答案就是 $\frac{n(n+1)}{2}-\sum\limits_{i\in [2, n]} lcp(i-1, i)$ 考虑如何快速求出这个lcp, 我们发现如果将后缀按照字典序排序, 那么必然有 $lcp(i-1, i)-1&lt;lcp(i, i+1)$, 那么我们就可以优化找 lcp 的过程, 即每次从 $lcp(i-2, i-1)$ 开始枚举来求 $lcp(i-1, i)$, 这样的话, 由于 $lcp(x, x+1) &lt; n$, 我们这个算法的总时间复杂度就是 O(n) 的. 如果采用倍增 SA 来排序后缀, 时间复杂度就是 O(nlogn) 的. 这个 $lcp$ 其实就是 $height$ 数组. 代码 code Problem 2 (「HAOI2016」找相同字符)题意 求两个字符串的相同子串个数 解法 考虑实现一个求出一个字符串中相同子串个数的算法, 那么我们要找的就是两个后缀的前缀相同, 考虑使用 SA. 然后考虑到$LCP(sa[i], sa[j]) = \min\limits_{k\in [l, r]}\{height[k]\}$, 那么我们可以利用差分思想+单调栈维护一个$height$的单调递减序列, 考虑被我们丢掉的$height$产生的贡献. 假设我们实现上诉算法为 $algo(str)$ 那么可以做一个容斥, 本题的答案就是 $algo(str1+’@’+str2)-algo(str1)-algo(str2)$ 代码 code]]></content>
      <tags>
        <tag>sa, sam, acam</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「WC2007」剪刀石头布 题解]]></title>
    <url>%2Fsolution-wc2007-paper-scissors-stone%2F</url>
    <content type="text"><![CDATA[题意给定一个竞赛图, 需要给一些边定向, 使得图中的三元环个数最少. 解法考虑容斥, 很明显, 我们考虑 $3$ 个点不构成三元环的情况. 考虑钦定一个不属于三元三个节点, 那么我们很明显有一个节点要选两条出边, 我们钦定这个节点是这三个节点的代表节点 那么很明显$Ans = \dbinom{n}{3} - \sum \dbinom{deg(u)}{2}$ 那么看到n很小, 考虑上网络流/费用流, 发现一条边只能往一个点流, 那么把每条边都拿出来然后往两个点(不需要定向就只往一个点)连边, 费用为0流量为1, 考虑到$\dbinom{deg(u)}{2} = \sum\limits_{i\in[0, deg(u))} i$, 那么所有点建出的点向汇点都连权值0~n的边表示减少的三元环数量, 跑最小费用最大流即可. 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include&lt;bits/stdc++.h&gt;using namespace std; /*Copyright [tyqtyq](http://oiertyq.github.io). All rights served.*/#define f(i,x,y) for(int i=x,i##end=y;i&lt;=i##end;++i)#define d(i,x,y) for(int i=x,i##end=y;i&gt;=i##end;--i)#define ri register int#define ll long long#define il inlinenamespace intio&#123;char ch; int read()&#123; ri x=0,f=1; while(!isdigit((ch=getchar()))) f=ch=='- '?-1:1; while(isdigit(ch)) x=x*10+ch-'0', ch=getchar(); return x*f; &#125; void read(int&amp; x) &#123;x = read();&#125;&#125;; using namespace intio;int max(int x, int y) &#123;return x&gt;y?x:y;&#125; int min(int x, int y) &#123;return x&lt;y?x:y;&#125;namespace mcmf &#123; const int _ = 20005; int head[_],ver[_*4],edge[_*4],Next[_*4],cost[_*4],tot=-1,s,t ; int flow[_],lst[_],dis[_],pre[_],vis[_]; int n,m,mf,mc ; void init()&#123; tot = -1 , memset(head,-1,sizeof(head)),memset(Next,-1,sizeof(Next)) ; &#125; void _add(int u,int v,int w,int f)&#123; ver[++tot]=v, edge[tot]=w, cost[tot]=f, Next[tot]=head[u], head[u]=tot ; &#125; void add(int u,int v,int w,int f)&#123; //printf("ADD : (%d, %d, %d, %d)\n", u,v,w,f); _add(u,v,w,f), _add(v,u,0,-f) ; &#125; int spfa(int s,int t)&#123; queue&lt;int&gt; Q; memset(dis,0x3f,sizeof(dis)); memset(flow,0x3f,sizeof(flow)); memset(vis,0,sizeof(vis)); Q.push(s); vis[s]=1; dis[s]=0; pre[t]=-1; while(!Q.empty())&#123; int d=Q.front(); Q.pop(); vis[d]=0; for(int i=head[d]; i!=-1; i=Next[i])&#123; if(edge[i]&gt;0 &amp;&amp; dis[ver[i]]&gt;dis[d]+cost[i])&#123; dis[ver[i]]=dis[d]+cost[i]; pre[ver[i]]=d; lst[ver[i]]=i; flow[ver[i]]=min(flow[d],edge[i]); !vis[ver[i]] &amp;&amp; (Q.push(ver[i]), vis[ver[i]]=1); &#125; &#125; &#125; return pre[t]!=-1; &#125; int mcmf()&#123; while(spfa(s,t))&#123; int now=t; mf+=flow[t]; mc+=flow[t]*dis[t]; while(now!=s)&#123; edge[lst[now]]-=flow[t]; edge[lst[now]^1]+=flow[t]; now=pre[now]; &#125; &#125; return mc; &#125;&#125;namespace sol &#123; #define _ 192 int mat[_][_], n, num[_][_], tot; pair&lt;int, int&gt; denum[_*_]; void solve() &#123; mcmf::init(); scanf("%d", &amp;n); f(i,1,n) f(j,1,n) &#123; scanf("%d", &amp;mat[i][j]); if(mat[i][j]==1 || (mat[i][j]==2 &amp;&amp; i&lt;j)) num[i][j]=++tot, denum[tot]=make_pair(i, j); &#125; mcmf::s=10001; mcmf::t=10002; f(i,1,n) f(j,1,n) &#123; if(mat[i][j]==1) mcmf::add(mcmf::s, num[i][j], 1, 0), mcmf::add(num[i][j], j+tot, 1, 0); if(mat[i][j]==2 &amp;&amp; i&lt;j) mcmf::add(mcmf::s, num[i][j], 1, 0), mcmf::add(num[i][j], i+tot, 1, 0), mcmf::add(num[i][j], j+tot, 1, 0); &#125; f(i,1,n) f(j,0,n) mcmf::add(i+tot, mcmf::t, 1, j); printf("%d\n", n*(n-1)/2*(n-2)/3-mcmf::mcmf()); memset(mat, 0, sizeof(mat)); f(u,1,n) &#123; for(int i=mcmf::head[u+tot]; i!=-1; i=mcmf::Next[i]) &#123; //printf("EDGE : (%d, %d)\n", u+tot, mcmf::ver[i]); if(mcmf::ver[i]&lt;=tot&amp;&amp;mcmf::edge[i]) mat[u][(u!=denum[mcmf::ver[i]].second)?denum[mcmf::ver[i]].second:denum[mcmf::ver[i]].first]=1; &#125; &#125; f(i,1,n) f(j,1,n) printf("%d%c", mat[i][j], " \n"[j==n]); &#125;&#125; ;int main()&#123; sol::solve(); return 0;&#125;// sto wyxkk orz]]></content>
      <tags>
        <tag>费用流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「WC2005」友好的生物 题解]]></title>
    <url>%2Fsolution-wc2005-friendly-animals%2F</url>
    <content type="text"><![CDATA[题意给定一个权值函数$f(a, b)=(\sum_{i=1}^{k-1} C_id_i)-C_Kd_K$用来计算 a, b 的友好程度. 其中 $C_i$ 是非负常数, $d_i$ 是$a, b$属性 $i$ 的差别 解法我们令$a_{k, i}$表示第 $k$ 个生物的第 $i$ 项属性. 明显$c_i$直接乘进$a_{k, i}$即可, 以下不加以讨论. 考虑不处理绝对值, 具体来说, 我们考虑一个更加宽泛但是最优解一定是原问题最优解的问题, 假设不处理最后一维, 那么我们的权值函数$f(x,y)$可以写成$f(x, y) = \max\limits_{c}{(-1)^{c_i}\times (a_{x, i}-a_{y, i})}$, 那么拆开括号, 此时题目要求的答案就是$\max\limits_{c}\{Mx_{\{c\}}+Mx_{\{d\}} | d_i=1-c_i\}$, 其中$Mx_{\{x\}}$表示$c$数列取$x$时, 生物$1\cdots n$计算的最大权值$f(x)=\sum\limits_{i} ((-1)^{c_i} \times a_{x, i})$ 加上最后一维的话, 可以按最后一位大小枚举然后更新$Mx$的值保证消去最后一维的绝对值 代码12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;bits/stdc++.h&gt;using namespace std; /*Copyright [tyqtyq](http://oiertyq.github.io). All rights served.*/#define f(i,x,y) for(int i=x,i##end=y;i&lt;=i##end;++i)#define d(i,x,y) for(int i=x,i##end=y;i&gt;=i##end;--i)#define ri register int#define ll long long#define il inlinenamespace intio&#123;char ch; int read()&#123; ri x=0,f=1; while(!isdigit((ch=getchar()))) f=ch=='- '?-1:1; while(isdigit(ch)) x=x*10+ch-'0', ch=getchar(); return x*f; &#125; void read(int&amp; x) &#123;x = read();&#125;&#125;; using namespace intio;int max(int x, int y) &#123;return x&gt;y?x:y;&#125; int min(int x, int y) &#123;return x&lt;y?x:y;&#125;#define _ 100005int c[_], n, k;typedef struct wyxkkakioi &#123; int a[5], b, num;&#125; ani;ani x[_];int Mx[(1&lt;&lt;4)], S[_][(1&lt;&lt;4)], f[(1&lt;&lt;4)];int a, b, ans=-0x3f3f3f3f, up;int cmp(ani x, ani y)&#123; return x.b&lt;y.b; &#125;int main()&#123; scanf("%d%d", &amp;n, &amp;k); up=(1&lt;&lt;4)-1; f(i,1,k) scanf("%d", &amp;c[i]); f(i,1,n) &#123; f(j,1,k-1) scanf("%d", &amp;x[i].a[j]), x[i].a[j]*=c[j]; scanf("%d", &amp;x[i].b), x[i].b*=c[k]; x[i].num=i; &#125; sort(x+1, x+n+1, cmp); f(i,1,n) f(U,0,up) f(l,0,3) S[i][U]+=(U&amp;(1&lt;&lt;l))?x[i].a[l+1]:-x[i].a[l+1]; f(U,0,up) Mx[U]=S[1][U]+x[1].b, f[U]=x[1].num; f(i,2,n) &#123; f(U,0,up) &#123; int newans=Mx[U^up]+S[i][U]-x[i].b; if(newans &gt; ans) ans=newans, a=f[U^up], b=x[i].num; &#125; f(U,0,up) if(Mx[U]&lt;S[i][U]+x[i].b) Mx[U]=S[i][U]+x[i].b, f[U]=x[i].num; &#125; printf("%d %d\n%d\n", a, b, ans); return 0;&#125;// sto wyxkk orz]]></content>
      <tags>
        <tag>杂题</tag>
      </tags>
  </entry>
</search>
